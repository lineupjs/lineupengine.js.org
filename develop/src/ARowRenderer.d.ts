import { IAbortAblePromise } from './abortAble';
import { IAnimationContext } from './animation';
import { IExceptionContext } from './logic';
import { EScrollResult, IMixinClass } from './mixin';
import { IDelayedMode } from './internal';
export declare type IRowRenderContext = IExceptionContext;
export interface IRowRendererOptions {
    async: IDelayedMode;
    minScrollDelta: number;
    batchSize: number;
    mixins: IMixinClass[];
    scrollingHint: boolean;
}
export declare abstract class ARowRenderer {
    protected readonly body: HTMLElement;
    private readonly pool;
    private readonly loadingPool;
    private readonly loading;
    private readonly fragment;
    protected readonly visible: {
        first: number;
        forcedFirst: number;
        last: number;
        forcedLast: number;
    };
    protected visibleFirstRowPos: number;
    private readonly adapter;
    private readonly mixins;
    private scrollListener;
    private abortAnimation;
    protected readonly options: Readonly<IRowRendererOptions>;
    constructor(body: HTMLElement, options?: Partial<IRowRendererOptions>);
    protected addMixin(mixinClass: IMixinClass, options?: any): void;
    private createAdapter();
    protected readonly bodyScroller: HTMLElement;
    protected readonly bodySizer: HTMLElement;
    protected readonly abstract context: IRowRenderContext;
    protected abstract createRow(node: HTMLElement, index: number): IAbortAblePromise<void> | void;
    protected abstract updateRow(node: HTMLElement, index: number): IAbortAblePromise<void> | void;
    protected init(): void;
    destroy(): void;
    private static cleanUp(item);
    private select(index);
    private selectProxy();
    private recycle(item);
    private proxy(item, result);
    private create(index);
    private removeAll();
    protected update(): void;
    protected forEachRow(callback: (row: HTMLElement, rowIndex: number) => void, inplace?: boolean): void;
    private removeFromBeginning(from, to);
    private removeFromBottom(from, to);
    private remove(from, to, fromBeginning);
    private addAtBeginning(from, to);
    private addAtBottom(from, to);
    protected updateOffset(firstRowPos: number): void;
    protected updateSizer(firstRowPos: number): void;
    protected recreate(ctx?: IAnimationContext): void;
    private recreatePure();
    private recreateAnimated(ctx);
    private animate(animation, phases, previousFinder, currentFinder, fragment);
    protected clearPool(): void;
    protected revalidate(): void;
    protected onScrolledVertically(scrollTop: number, clientHeight: number, isGoingDown: boolean): EScrollResult;
    private shiftLast(current, currentDelta);
    private shiftFirst(current, currentFirstRow, currentDelta);
    private onScrolledImpl(scrollTop, clientHeight);
}
export default ARowRenderer;
